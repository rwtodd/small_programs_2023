#!/usr/bin/env perl
use v5.36;
use Getopt::Std;
use File::Basename qw(fileparse);

# Re-encode movies to HEVC mp4s (-crf around 25) 
# with the hvc1 tag so apple/quicktime understands 
# what's happening... 
# Just copy the audio as-is.  If the video is already 
# hevc, just copy the video and retag it.  If the 
# video is larger than 720p, then downscale it to 720p.
#
my $DownTo720 = undef;
my $CopyHEVC = undef;
my $crflevel = undef;
my @chapts = qw/-dn -map_chapters -1/;
my @extargs = ();
my $dryrun = undef;
my @quietMode = qw/-hide_banner -loglevel error/;
my @x265parms = qw/-x265-params log-level=error/;
my @statusarg = ();
my $keeplarge = undef;
my @audioparms = qw/-c:a copy/;

# print text in dry-run or verbose mode
sub vecho {
  say(@_) if($dryrun || !@quietMode);
}

# collectinfo <filename>
sub collectinfo($fn) {
  open(my $probe, '-|', 
      "ffprobe -i \"$fn\" -select_streams v:0 -show_entries stream='height,codec_name' " . 
      '-of default=noprint_wrappers=1:nokey=0 -v error');
  while(<$probe>) {
    chomp;
    if(m/^codec_name=(.*)$/) {
      vecho("Codec is <$1>");
      $CopyHEVC = $1 eq 'hevc';
    } elsif(m/^height=(\d+)$/) {
      vecho("Height is <$1>");
      $DownTo720 = $1 > 720 && !$keeplarge;
    } else {
      vecho("unknown line <$_>");
    }
  }
  close($probe);
  if($DownTo720) { $CopyHEVC = undef } # can't rescale and copy!
}

# check for input arguments
my %opts;
getopts('2:a:c:de:hlmsv', \%opts) or die "Bad options!";
if($opts{h}) {
  say <<'USAGE';
Usage: convert-mp4s [options] filenames...
  -2 brate   mixdown to 2 channels and use the aac_at aac encoder at <brate> rate
  -a brate   use the aac_at aac encoder at <brate> rate
  -c crf     to set the CRF level for encoding (default 25)
  -d         for dry-run (don't actually run ffmpeg)
  -e args    to supply extra args to ffmpeg's output section
  -l         large (don't downscale to 720p)
  -m         include metadata for chapters (removed by default)
  -s         for encoding status output
  -v         for verbose output
USAGE
  exit(1);
}

@audioparms = (qw/-c:a aac_at -b:a/, "$opts{a}k") if $opts{a};
@audioparms = (qw/-ac 2 -c:a aac_at -b:a/, "$opts{2}k") if $opts{2};
$crflevel = $opts{c} // 25;
$dryrun = 1 if $opts{d};
@chapts = () if $opts{m};
@extargs = split(' ',$opts{e}) if $opts{e};
$keeplarge = 1 if $opts{l};
@statusarg = qw/-stats/ if $opts{s};
@quietMode = @x265parms = () if $opts{v};

my $exitCode=0;
while(my $infile = shift) {
  vecho('**********************************************************************');
  vecho("Processing <$infile>");
  if(! -f $infile ) {
    say STDERR "<$infile> does not exist";
    $exitCode=1;
    next; 
  } 

  my $converted = (fileparse($infile,qr/\.[^.]*$/) =~ s/[^[:alnum:]]+/_/gr) . '.mp4';
  vecho("Going to write output <$converted>");
  if( -e $converted) {
    say STDERR "<$converted> output file already exists!";
    $exitCode = 1;
    next;
  }

  collectinfo($infile);
  vecho('CopyHEVC   =  ' . ($CopyHEVC?'yes':'no'));
  vecho('DownTo720  =  ' . ($DownTo720?'yes':'no'));
  vecho("CRF Level  =  $crflevel");
  vecho("Audio args =  <@audioparms>");
  vecho("Extra args =  <@extargs>") if @extargs;

  if ($dryrun) {
    say 'Would run ffmpeg here, but -d (for dry-run) was given on command line.';
    next;
  } 

  # Build up the ffmpeg command-line in an $args array
  my $thisCRF = $crflevel;
  my @cmd = ('ffmpeg', @quietMode, @statusarg, '-i', $infile, '-sn');
  if ($DownTo720) {
    $thisCRF--;
    vecho("Downscaling to 720p. CRF improved to $thisCRF");
    push @cmd, qw/-vf scale=-1:720/;
  }

  if ($CopyHEVC) {
    vecho('Copying HEVC video (not re-encoding)');
    push @cmd, qw/-c:v copy/;
  } else {
    push @cmd, (qw/-c:v libx265 -crf/, $thisCRF);
  }
  
  push @cmd, ('-tag:v', 'hvc1', @x265parms, @audioparms, @chapts, @extargs, $converted);
  vecho("Command is <@cmd>");
  system @cmd;
} continue {
  vecho('');
}
exit($exitCode);
